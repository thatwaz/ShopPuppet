package com.thatwaz.shoppuppet.presentation.viewmodel

import android.util.Log
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.thatwaz.shoppuppet.data.repository.ShopRepository
import com.thatwaz.shoppuppet.domain.model.Shop
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.launch
import javax.inject.Inject




@HiltViewModel
class ShopsViewModel @Inject constructor(
    private val shopRepository: ShopRepository
) : ViewModel() {

    private val _shops = MutableLiveData<List<Shop>>()

    // todo track issue with icon defaulting to edit icon after clean and rebuild

    /*
The fact that the icon change occurred after a clean and rebuild operation in Android Studio points
 towards a potential issue with resource IDs being reassigned during the build process. Here are some
 steps to investigate and resolve this issue:

Resource ID Stability: In Android, resource IDs are generated by the build system and are not guaranteed
to be stable across builds. This means that after a clean build, the ID assigned to a particular resource
 (like your grocery cart icon) might change. If your application logic or database relies on these IDs
 remaining constant, this could be the root of the problem.

Database Storing Strategy: Review how you are storing the icon information in the database. If you are
storing the integer resource ID directly, this might lead to the issue you're observing. After a rebuild,
the IDs can change, and the database might point to a wrong resource (like the pencil icon). A more
reliable approach is to store a unique, unchanging identifier for each icon (like a name or a custom ID)
and map these to the appropriate drawable resources in your code.

Drawable Resource Check: Double-check the drawable resources in your res/drawable directory.
Ensure that each icon has a unique and clearly distinguishable name. Sometimes, similar names or
accidental duplication might lead to confusion or mistakes in the code.

Code Audit: Examine the code where icons are assigned to the shops. Ensure that the logic for
selecting and displaying the icons is based on a stable identifier (like a name or custom ID) rather
than the resource ID, which can change.

Manual Testing: After making changes, manually test the functionality that involves icon assignment
to confirm that the correct icons are displayed. This can help catch any issues that automated tests
or the compiler might miss.

Resource Qualifiers: If you use different drawable resources for different configurations (like locales
 or screen sizes), make sure there's no confusion or overlap between these resources.

Consistent Build Process: Try to maintain a consistent build process. Frequent cleans and rebuilds
can sometimes lead to unpredictable behavior, especially with resource IDs.

Version Control: If you're using a version control system, compare the code and resources before and
after the change to see if there were any unintended modifications.

By ensuring that you use stable identifiers for your drawable resources and by carefully managing
 how these identifiers are stored and used in your application, you can prevent such issues from
 occurring after clean builds or changes in the codebase.

     */
    val shops: LiveData<List<Shop>> get() = _shops

    init {
        fetchShops()
    }

    private fun fetchShops() {
        viewModelScope.launch {
            _shops.value = shopRepository.getAllShops()
            Log.i("DOH!","Shops are ${_shops.value}")
        }
    }

    fun deleteShop(shop: Shop) {
        viewModelScope.launch {
            shopRepository.deleteShop(shop)
            fetchShops() // Refresh the shops list
        }
    }
}

//@HiltViewModel
//class ShopsViewModel @Inject constructor(
//    private val shopRepository: ShopRepository
//) : ViewModel() {
//
//    private val _shops = MutableLiveData<List<Shop>>()
//    val shops: LiveData<List<Shop>> get() = _shops
//
//    val allShops: LiveData<List<Shop>> = liveData {
//        emit(shopRepository.getAllShops())
//    }
//
//    // This function may not be necessary if you use the liveData builder as above
//    fun fetchShops() {
//        viewModelScope.launch {
//            _shops.value = shopRepository.getAllShops()
//        }
//    }
//
//    fun deleteShop(shop: Shop) {
//        viewModelScope.launch {
//            try {
//                shopRepository.deleteShop(shop)
//                val updatedShops = shopRepository.getAllShops()
////                _allShops.value = updatedShops
//
//                // Optionally, refresh the list of shops or post a success message
//            } catch (e: Exception) {
//                // Handle any exceptions, e.g., show an error message
//            }
//        }
//    }
//}







//@HiltViewModel
//class ShopViewModel @Inject constructor(
//    private val shopRepository: ShopRepository
//) : ViewModel() {
//
//    val shops = MutableLiveData<List<Shop>>()
//
//    fun fetchShops() {
//        viewModelScope.launch {
//            shops.value = shopRepository.getAllShops()
//        }
//    }
//
//
//}
